{
  "resolvedId": "/Users/ilaolovannikov/WebstormProjects/ithub-vue/node_modules/.pnpm/@farfetched+core@0.13.1_effector@23.3.0/node_modules/@farfetched/core/dist/core.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { createStore as x, is as q, combine as O, createEffect as k, attach as T, sample as c, createEvent as $, createNode as Fe, step as dt, split as J, withRegion as pt, merge as ce, scopeBind as Ie, createApi as mt } from \"effector\";\nconst re = {\n  isData: (e) => !0,\n  getErrorMessages: () => []\n};\nfunction D({\n  field: e\n}) {\n  let t;\n  if (e === void 0)\n    t = x((r) => null, {\n      serialize: \"ignore\",\n      name: \"ff.$target/undefined\",\n      sid: \"ff.$target/undefined\"\n    });\n  else if (q.store(e))\n    t = O(\n      e,\n      (n) => (a) => n ?? null\n    );\n  else if (e != null && e.source && (e != null && e.fn)) {\n    const r = e;\n    t = O(\n      r.source,\n      (n) => (a) => r.fn(a, n) ?? null\n    );\n  } else if (typeof e == \"function\") {\n    const r = e;\n    t = x(\n      (n) => r(n) ?? null,\n      {\n        serialize: \"ignore\",\n        name: \"ff.$target/callbackField\",\n        sid: \"ff.$target/$callbackField\"\n      }\n    );\n  } else {\n    const r = e;\n    t = x((n) => r ?? null, {\n      serialize: \"ignore\",\n      name: \"ff.$target/valueField\",\n      sid: \"ff.$target/$valueField\"\n    });\n  }\n  return t;\n}\nfunction ht(e) {\n  let t;\n  if (e === void 0)\n    t = k(async (r) => null);\n  else if (q.store(e))\n    t = T({\n      source: e,\n      async effect(n, a) {\n        return n;\n      }\n    });\n  else if (e.source && e.fn) {\n    const r = e;\n    t = T({\n      source: r.source,\n      async effect(n, a) {\n        return r.fn(a, n);\n      }\n    });\n  } else if (typeof e == \"function\") {\n    const r = e;\n    t = k(async (n) => r(n));\n  } else {\n    const r = e;\n    t = k(async (n) => r);\n  }\n  return t;\n}\nfunction R(e) {\n  return e ? q.store(e) ? e : x(e, {\n    serialize: \"ignore\",\n    name: \"ff.$target/valueField\",\n    sid: \"ff.$target/$valueField\"\n  }) : x(null, {\n    serialize: \"ignore\",\n    name: \"ff.$target/undefined\",\n    sid: \"ff.$target/$undefined\"\n  });\n}\nfunction yt(e) {\n  return q.store(e) ? e : e != null && e.source ? e.source : null;\n}\nfunction Sr(e, t) {\n  const r = {}, n = {};\n  for (const [o, s] of Object.entries(e))\n    q.store(s) ? r[o] = s : s != null && s.source && (s != null && s.fn) ? (r[o] = s.source, n[o] = s.fn) : typeof s == \"function\" ? n[o] = s : r[o] = s;\n  return {\n    source: O(r),\n    fn: (o, s) => {\n      const i = {};\n      for (const l of Object.keys(e))\n        l in s && (i[l] = s[l]), l in n && (i[l] = n[l](o, s[l]));\n      return t ? t(i) : i;\n    }\n  };\n}\nfunction Te({\n  clock: e,\n  timeout: t,\n  target: r = $()\n}) {\n  const n = k(\n    ({ payload: a, milliseconds: o }) => new Promise((s) => {\n      setTimeout(s, o, a);\n    })\n  );\n  return c({\n    source: R(t),\n    clock: e,\n    fn: (a, o) => ({\n      payload: o,\n      milliseconds: a\n    }),\n    target: n\n  }), c({\n    clock: n.doneData,\n    target: r\n  }), r;\n}\nfunction le(e, t) {\n  let r = [], n = () => !1;\n  Array.isArray(e) ? (r = e, n = t) : Array.isArray(e.stores) && (r = e.stores, n = e.predicate);\n  let a;\n  gt(n) ? a = n : q.store(n) ? a = n.map((i) => (l) => i === l) : a = (i) => i === n;\n  const o = O(r);\n  return O(a, o, (i, l) => l.every(i));\n}\nfunction gt(e) {\n  return typeof e == \"function\";\n}\nfunction H(e) {\n  return e.map((t) => !t);\n}\nfunction De(...e) {\n  return le({ predicate: !0, stores: e });\n}\nfunction je({\n  clock: e,\n  until: t\n}) {\n  const r = $(), n = x(!1, {\n    serialize: \"ignore\",\n    name: \"ff.$fired\",\n    sid: \"ff.$fired\"\n  }).on(r, () => !0).on(e, () => !1);\n  return c({\n    clock: [e, t],\n    source: e,\n    filter: De(t, H(n)),\n    target: r\n  }), r;\n}\nfunction se(e) {\n  if (e === \"ignore\")\n    return \"ignore\";\n}\nconst ke = k(() => Date.now());\nfunction $t({\n  clock: e\n}) {\n  const t = x(Date.now(), {\n    name: \"ff.$time\",\n    sid: \"ff.$time\"\n  });\n  return c({\n    clock: e,\n    fn: () => {\n    },\n    target: ke\n  }), c({ clock: ke.doneData, target: t }), t;\n}\nfunction E(e) {\n  return e.map((t) => t, { skipVoid: !1 });\n}\nfunction _t(e) {\n  const t = $(), r = x(null, {\n    serialize: \"ignore\",\n    name: \"ff.$timeoutId\",\n    sid: \"ff.$timeoutId\"\n  }).on(t, (g, f) => f), n = $(), a = x(null, {\n    serialize: \"ignore\",\n    name: \"ff.$rejecter\",\n    sid: \"ff.$rejecter\"\n  }).on(n, (g, f) => f), o = $(), s = T({\n    source: {\n      timeoutId: r,\n      rejectPromise: a\n    },\n    effect: ({ timeoutId: g, rejectPromise: f }) => (g && clearTimeout(g), f && f(), new Promise((_, u) => {\n      n(u), t(setTimeout(_, 0));\n    }))\n  });\n  a.reset(s.done), r.reset(s.done);\n  const i = x([], {\n    serialize: \"ignore\",\n    name: \"ff.$payload\",\n    sid: \"ff.$payload\"\n  }).on(e, (g, f) => [f]), l = x(!0, {\n    serialize: \"ignore\",\n    sid: \"ff.$canTick\",\n    name: \"ff.$canTick\"\n  }), y = $();\n  return l.on(y, () => !1).on(\n    [\n      o,\n      // debounce timeout can be restarted in later ticks\n      s\n    ],\n    () => !0\n  ), c({\n    clock: e,\n    filter: l,\n    target: y\n  }), c({\n    clock: y,\n    target: s\n  }), c({\n    source: i,\n    clock: s.done,\n    fn: ([g]) => g,\n    target: o\n  }), o;\n}\nfunction ve(e, t) {\n  const r = Object.entries(e).map(\n    ([n, a]) => [n, t(a)]\n  );\n  return Object.fromEntries(r);\n}\nfunction be(e) {\n  const t = {};\n  for (const [r, n] of Object.entries(e))\n    for (const [a, o] of Object.entries(n))\n      t[a] = { ...t[a], [r]: o };\n  return t;\n}\nfunction kt({ min: e, max: t }) {\n  return Math.random() * (t - e) + e;\n}\nfunction vt() {\n  const e = {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    resolve: () => {\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    reject: () => {\n    },\n    // @ts-expect-error it will be set later\n    promise: null\n  };\n  return e.promise = new Promise((t, r) => {\n    e.resolve = t, e.reject = r;\n  }), e.promise.catch(() => {\n  }), e;\n}\nfunction bt(e) {\n  return e == null;\n}\nfunction we(e) {\n  return !bt(e);\n}\nfunction Z(e, t) {\n  try {\n    if (e === t || Number.isNaN(e) && Number.isNaN(t))\n      return !0;\n    const r = Ae(e), n = Ae(t);\n    if (r !== n)\n      return !1;\n    if (r === \"pure-object\") {\n      if (e === t)\n        return !0;\n      const a = Object.keys(e), o = Object.keys(t).length;\n      if (a.length !== o)\n        return !1;\n      for (let s = 0, i = a.length; s < i; s++) {\n        const l = a[s];\n        if (!Object.prototype.hasOwnProperty.call(t, a[s]))\n          return !1;\n        const y = e[l], g = t[l];\n        if (y === e || g === t || y === t || g === e)\n          return y === g;\n        if (!Z(y, g))\n          return !1;\n      }\n      return !0;\n    } else if (r === \"array\") {\n      if (e.length === t.length)\n        for (let a = 0; a < e.length; a++) {\n          const o = e[a], s = t[a];\n          if (o === e || s === t || o === t || s === e)\n            return o === s;\n          if (!Z(o, s))\n            return !1;\n        }\n      else\n        return !1;\n      return !0;\n    } else if (r === \"object\" && e.valueOf && t.valueOf)\n      return e.valueOf() === t.valueOf();\n  } catch {\n  }\n  return !1;\n}\nfunction wt(e) {\n  if (Array.isArray(e))\n    return !0;\n  const t = e.length;\n  return typeof t == \"number\" && t > -1 ? t ? 0 in e && t - 1 in e : !0 : !1;\n}\nfunction Ae(e) {\n  const t = typeof e;\n  return t === \"object\" ? e === null ? \"null\" : wt(e) ? \"array\" : e.constructor === Object || Object.getPrototypeOf(e) === null ? \"pure-object\" : \"object\" : t;\n}\nfunction At(e, t) {\n  const r = [], n = [];\n  for (const a of e)\n    t(a) ? r.push(a) : n.push(a);\n  return [r, n];\n}\nfunction U(e) {\n  return (t) => t[e];\n}\nfunction xt(e) {\n  return Array.from(new Set(e));\n}\nclass Et {\n  constructor(t = !1) {\n    this._resolve = null, this._promise = Promise.resolve(), t && this.acquire();\n  }\n  get isLocked() {\n    return !!this._resolve;\n  }\n  acquire() {\n    this.isLocked || (this._promise = new Promise((t) => {\n      this._resolve = t;\n    }));\n  }\n  waitForUnlock() {\n    return this._promise;\n  }\n  release() {\n    this._resolve && (this._resolve(), this._resolve = null);\n  }\n}\nfunction Pt({\n  events: e,\n  reset: t\n}) {\n  const r = $(), n = x([], { serialize: \"ignore\" });\n  return t && c({ clock: t, target: n.reinit }), e.forEach((a, o) => {\n    n.on(a, (s) => xt([...s, o]));\n  }), c({\n    clock: e,\n    source: n,\n    filter: (a) => a.length === e.length,\n    target: r\n  }), r;\n}\nfunction Oe() {\n  var e, t;\n  return ((t = (e = Fe({ regional: !0 }).family.owners[0]) == null ? void 0 : e.meta) == null ? void 0 : t.name) ?? void 0;\n}\nconst Re = \"INVALID_DATA\", qe = \"TIMEOUT\", Ne = \"ABORT\", Le = \"PREPARATION\", Me = \"HTTP\", ze = \"NETWORK\", St = \"CONFIGURATION\";\nfunction ee(e) {\n  return {\n    ...e,\n    errorType: Re,\n    explanation: \"Response was considered as invalid against a given contract\"\n  };\n}\nfunction Ft(e) {\n  return {\n    ...e,\n    errorType: qe,\n    explanation: \"Request was cancelled due to timeout\"\n  };\n}\nfunction Ce() {\n  return {\n    errorType: Ne,\n    explanation: \"Request was cancelled due to concurrency policy\"\n  };\n}\nfunction It(e) {\n  return {\n    ...e,\n    errorType: Le,\n    explanation: \"Extraction of data from the response was failed\"\n  };\n}\nfunction Be(e) {\n  return {\n    ...e,\n    errorType: Me,\n    explanation: \"Request was finished with unsuccessful HTTP code\"\n  };\n}\nfunction Tt(e) {\n  return {\n    ...e,\n    errorType: ze,\n    explanation: \"Request was failed due to network problems\"\n  };\n}\nfunction ie(e) {\n  return {\n    ...e,\n    errorType: St,\n    explanation: \"Operation is misconfigured\"\n  };\n}\nfunction Dt(e) {\n  return k({\n    handler: ({ result: r }) => {\n      if (!e.isData(r))\n        throw ee({\n          validationErrors: e.getErrorMessages(r),\n          response: r\n        });\n      return r;\n    },\n    sid: \"ff.applyContractFx\"\n  });\n}\nfunction jt(e) {\n  return !!(e === !0 || Array.isArray(e) && e.length === 0 || typeof e == \"string\" && e.length === 0);\n}\nfunction xe(e) {\n  return e === !0 ? [] : e === !1 ? [\"Invalid data\"] : Array.isArray(e) ? e.length === 0 ? [] : e : [e];\n}\nconst Ot = () => !0;\nfunction Fr(e) {\n  var t;\n  return ((t = e.error) == null ? void 0 : t.errorType) === Re;\n}\nfunction Ir(e) {\n  var t;\n  return ((t = e.error) == null ? void 0 : t.errorType) === qe;\n}\nfunction Rt(e) {\n  var t;\n  return ((t = e.error) == null ? void 0 : t.errorType) === Ne;\n}\nfunction Tr(e) {\n  var t;\n  return ((t = e.error) == null ? void 0 : t.errorType) === Le;\n}\nfunction He(e) {\n  var t;\n  return ((t = e.error) == null ? void 0 : t.errorType) === Me;\n}\nfunction Dr(e) {\n  return function(r) {\n    return He(r) ? (Array.isArray(e) ? e : [e]).includes(r.error.status) : !1;\n  };\n}\nfunction jr(e) {\n  var t;\n  return ((t = e.error) == null ? void 0 : t.errorType) === ze;\n}\nlet te = null, ue = !1;\nfunction qt() {\n  ue = !0;\n}\nfunction Nt() {\n  ue = !1;\n}\nfunction Ue(e) {\n  if (!ue)\n    throw ie({\n      reason: \"onAbort call is not allowed\",\n      validationErrors: [\n        \"onAbort can be called only in the context of a handler before any async operation is performed\"\n      ]\n    });\n  if (te)\n    throw ie({\n      reason: \"onAbort call is not allowed\",\n      validationErrors: [\"onAbort can be called only once per operation\"]\n    });\n  te = e;\n}\nfunction Lt() {\n  const e = te;\n  return te = null, e;\n}\nfunction Mt(e) {\n  const t = $(e.shortName + \".internalCall\"), r = dt.compute({\n    fn: (a) => {\n      const o = a.handler, s = zt(o, t);\n      return a.handler = s, a;\n    }\n  });\n  return Ct(e).seq.splice(1, 0, r), t;\n}\nfunction zt(e, t) {\n  function r(...n) {\n    const { result: a, abortCallback: o } = Ut(e, ...n);\n    if (a instanceof Promise) {\n      const s = vt(), i = Ee(s, o);\n      return t(i), a.then(s.resolve, s.reject), s.promise;\n    } else {\n      const s = Ee(void 0, o);\n      return t(s), a;\n    }\n  }\n  return r;\n}\nfunction Ee(e, t) {\n  let r = e ? \"pending\" : \"finished\";\n  function n() {\n    r = \"finished\", a.status = r;\n  }\n  e && e.promise.then(n, n);\n  const a = {\n    id: Ht(),\n    status: r,\n    abort: (o = Ce()) => {\n      t == null || t(), r !== \"finished\" && e && e.reject(o);\n    },\n    promise: e == null ? void 0 : e.promise\n  };\n  return a;\n}\nfunction Ct(e) {\n  return e.graphite.scope.runner;\n}\nlet Bt = 0;\nfunction Ht() {\n  return `${Bt++}`;\n}\nfunction Ut(e, ...t) {\n  Vt(), qt();\n  const r = e(...t), n = Lt();\n  return Nt(), {\n    result: r,\n    abortCallback: n\n  };\n}\nconst Vt = $();\nfunction Ve(e, {\n  strategy: t,\n  abortAll: r\n}) {\n  e.__.meta.flags.concurrencyFieldUsed && console.error(\n    `Both concurrency-operator and concurrency-field are used on operation ${e.__.meta.name}.`,\n    \"Please use only concurrency-operator, because field concurrency-field in createJsonQuery and createJsonMutation is deprecated and will be deleted soon.\"\n  ), e.__.meta.flags.concurrencyOperatorUsed = !0;\n  const n = Qe(e);\n  if (t)\n    switch (t) {\n      case \"TAKE_EVERY\":\n        break;\n      case \"TAKE_FIRST\": {\n        const a = x(!1, { serialize: \"ignore\" }), o = $();\n        c({\n          clock: o,\n          fn: () => !0,\n          target: a\n        });\n        const s = {\n          name: \"concurrency\",\n          get: T({\n            source: a,\n            async effect(i, l) {\n              if (i)\n                throw Ce();\n              return o(), null;\n            }\n          })\n        };\n        e.__.lowLevelAPI.dataSources.unshift(s), c({\n          clock: e.finished.finally,\n          fn: () => !1,\n          target: a\n        });\n        break;\n      }\n      case \"TAKE_LATEST\": {\n        c({\n          clock: e.__.lowLevelAPI.callObjectCreated,\n          source: n,\n          fn: (a, o) => a.filter((s) => s !== o),\n          target: fe\n        });\n        break;\n      }\n    }\n  return r && Ke(e, { clock: r }), e;\n}\nfunction Ke(e, { clock: t }) {\n  c({ clock: t, source: Qe(e), target: fe });\n}\nfunction Qe(e) {\n  if (!e.__.meta.$callObjects) {\n    const t = x([], { serialize: \"ignore\" });\n    c({\n      clock: e.__.lowLevelAPI.callObjectCreated,\n      source: t,\n      fn: (r, n) => r.filter((a) => a.status === \"pending\").concat(n),\n      target: t\n    }), c({\n      clock: fe.done,\n      source: t,\n      fn: (r, { params: n }) => r.filter((a) => !n.includes(a)),\n      target: t\n    }), e.__.meta.$callObjects = t;\n  }\n  return e.__.meta.$callObjects;\n}\nconst fe = k(\n  (e) => e.forEach((t) => t.abort())\n), ne = Symbol(\"Meta\"), ae = Symbol(\"Result\");\nfunction Kt(e) {\n  return typeof e == \"object\" && e !== null && ne in e && ae in e;\n}\nfunction Je({\n  name: e,\n  meta: t,\n  kind: r,\n  serialize: n,\n  enabled: a,\n  contract: o,\n  validate: s,\n  mapData: i,\n  sourced: l,\n  paramsAreMeaningless: y\n}) {\n  const g = $(), f = $(), _ = $(), u = $(), p = Dt(\n    o\n  ), m = e ?? \"unnamed\", d = k({\n    handler: () => {\n      throw new Error(\"Not implemented\");\n    },\n    sid: `ff.${m}.executeFx`,\n    name: `${m}.executeFx`\n  }), w = Mt(d), F = [{\n    name: \"remote_source\",\n    get: k(async ({ params: h }) => {\n      const v = await d(h);\n      return Kt(v) ? {\n        result: v[ae],\n        stale: !1,\n        meta: v[ne]\n      } : { result: v, stale: !1 };\n    })\n  }], {\n    retrieveDataFx: I,\n    notifyAboutNewValidDataFx: N,\n    notifyAboutDataInvalidationFx: C\n  } = Qt(F), B = $(), b = $(), S = $();\n  c({\n    clock: B,\n    fn: (h) => ({\n      params: h,\n      meta: { stopErrorPropagation: !1, stale: !0 }\n    }),\n    target: u\n  });\n  const A = {\n    success: $(),\n    failure: $(),\n    skip: $(),\n    finally: $()\n  }, M = $(), V = $(), K = $();\n  J({\n    source: M,\n    match: {\n      aborted: ({ error: h }) => Rt({ error: h })\n    },\n    cases: {\n      aborted: K,\n      __: A.failure\n    }\n  });\n  const L = x(\"initial\", {\n    sid: `ff.${m}.$status`,\n    name: `ff.${m}.$status`,\n    serialize: n\n  });\n  c({ clock: b, target: L.reinit });\n  const G = x([], {\n    serialize: \"ignore\",\n    name: `ff.${m}.$statusHistory`,\n    sid: `ff.${m}.$statusHistory`\n  });\n  c({\n    clock: L.updates,\n    source: G,\n    fn: (h, v) => [...h, v],\n    target: G\n  });\n  const Q = R(a ?? !0).map(Boolean), ye = x(void 0, {\n    serialize: \"ignore\",\n    name: `ff.${m}.$latestParams`,\n    sid: `ff.${m}.$latestParams`,\n    skipVoid: !1\n  }), ct = L.map((h) => h === \"initial\"), it = L.map((h) => h === \"pending\"), lt = L.map((h) => h === \"fail\"), ut = L.map((h) => h === \"done\"), ft = L.map((h) => [\"fail\", \"done\"].includes(h));\n  c({\n    clock: [\n      I.map(() => \"pending\"),\n      A.success.map(() => \"done\"),\n      A.failure.map(() => \"fail\"),\n      c({\n        clock: K,\n        source: {\n          history: G,\n          retrieveDataPengind: I.pending\n        },\n        fn: ({ history: h, retrieveDataPengind: v }) => v ? \"pending\" : h[h.length - 2] ?? \"initial\"\n      })\n    ],\n    target: L\n  }), c({\n    clock: u,\n    filter: Q,\n    fn: ({ params: h }) => h,\n    target: ye\n  }), c({\n    clock: B,\n    filter: H(Q),\n    fn(h) {\n      return {\n        params: h,\n        meta: { stopErrorPropagation: !1, stale: !1 }\n      };\n    },\n    target: A.skip\n  }), c({\n    clock: g,\n    fn: ({ params: h }) => ({\n      params: h,\n      meta: { stopErrorPropagation: !1, stale: !0 }\n    }),\n    target: C\n  }), c({\n    clock: C.finally,\n    source: g,\n    filter: ({ refresh: h }) => h,\n    fn: ({ params: h }) => ({\n      params: h,\n      meta: { stopErrorPropagation: !1, stale: !0 }\n    }),\n    target: u\n  }), c({\n    clock: u,\n    filter: Q,\n    target: I\n  }), c({ clock: I, target: S }), c({\n    clock: I.done,\n    fn: ({ params: h, result: v }) => ({\n      params: h.params,\n      result: v.result,\n      meta: {\n        stopErrorPropagation: v.stopErrorPropagation ?? !1,\n        stale: v.stale,\n        responseMeta: v.meta\n      }\n    }),\n    filter: Q,\n    target: p\n  }), c({\n    clock: I.fail,\n    source: Q,\n    filter: (h, { error: v }) => h && !v.stopErrorPropagation,\n    fn: (h, { error: v, params: j }) => ({\n      error: v.error,\n      params: j.params,\n      meta: { stopErrorPropagation: v.stopErrorPropagation, stale: !1 }\n    }),\n    target: M\n  });\n  const { validDataRecieved: ge, __: $e } = J(\n    c({\n      clock: p.done,\n      source: {\n        partialValidator: D({\n          field: s ?? Ot\n        })\n      },\n      fn: ({ partialValidator: h }, {\n        params: {\n          /* Extract original params, it is params of params */\n          params: v,\n          meta: j\n        },\n        result: z\n      }) => ({\n        result: z,\n        params: v,\n        validation: h({\n          result: z,\n          params: v\n        }),\n        meta: j\n      })\n    }),\n    {\n      validDataRecieved: ({ validation: h }) => jt(h)\n    }\n  );\n  c({\n    clock: ge,\n    source: {\n      partialMapper: D({\n        field: i\n      })\n    },\n    fn: ({ partialMapper: h }, { params: v, result: j, meta: z }) => ({\n      result: h({\n        params: v,\n        result: j,\n        ...Jt(z) ? z.responseMeta : {}\n      }),\n      params: v,\n      meta: z\n    }),\n    target: A.success\n  }), c({\n    clock: A.success,\n    filter: ({ meta: h }) => h.stale,\n    fn: ({ params: h, meta: v }) => ({ params: h, meta: v, skipStale: !0 }),\n    target: I\n  }), c({\n    clock: ge,\n    filter: ({ meta: h }) => !h.stale,\n    target: N\n  }), c({\n    clock: p.fail,\n    filter: ({ params: h }) => !h.meta.stopErrorPropagation,\n    fn: ({ error: h, params: v }) => ({\n      error: h,\n      // Extract original params, it is params of params\n      params: v.params,\n      meta: v.meta\n    }),\n    target: M\n  }), c({\n    clock: p.fail,\n    fn: ({ error: h, params: v }) => ({\n      error: h,\n      // Extract original params, it is params of params\n      params: v.params,\n      meta: v.meta\n    }),\n    target: V\n  }), c({\n    clock: $e,\n    filter: ({ meta: h }) => !h.stopErrorPropagation,\n    fn: ({ params: h, validation: v, meta: j, result: z }) => ({\n      params: h,\n      error: ee({\n        validationErrors: xe(v),\n        response: z\n      }),\n      meta: j\n    }),\n    target: M\n  }), c({\n    clock: $e,\n    fn: ({ params: h, validation: v, meta: j, result: z }) => ({\n      params: h,\n      error: ee({\n        validationErrors: xe(v),\n        response: z\n      }),\n      meta: j\n    }),\n    target: V\n  }), c({\n    clock: Q.updates,\n    source: B,\n    filter: H(Q),\n    fn: (h) => ({\n      params: h,\n      meta: {\n        stopErrorPropagation: !1,\n        stale: !0\n      }\n    }),\n    target: A.skip\n  }), c({\n    clock: A.success,\n    fn: ({ params: h, result: v, meta: j }) => ({\n      status: \"done\",\n      params: h,\n      result: v,\n      meta: j\n    }),\n    target: A.finally\n  }), c({\n    clock: A.failure,\n    fn: ({ params: h, error: v, meta: j }) => ({\n      status: \"fail\",\n      params: h,\n      error: v,\n      meta: j\n    }),\n    target: A.finally\n  }), c({\n    clock: A.skip,\n    fn: ({ params: h, meta: v }) => ({\n      status: \"skip\",\n      params: h,\n      meta: v\n    }),\n    target: A.finally\n  });\n  const _e = {\n    start: B,\n    finished: A,\n    started: S,\n    aborted: K,\n    reset: b,\n    $status: L,\n    $idle: ct,\n    $pending: it,\n    $failed: lt,\n    $succeeded: ut,\n    $finished: ft,\n    $enabled: Q,\n    __: {\n      executeFx: d,\n      meta: { ...t, name: m, flags: {} },\n      kind: r,\n      $latestParams: E(ye),\n      lowLevelAPI: {\n        dataSources: F,\n        dataSourceRetrieverFx: I,\n        sourced: l ?? [],\n        paramsAreMeaningless: y ?? !1,\n        revalidate: g,\n        pushError: _,\n        pushData: f,\n        startWithMeta: u,\n        callObjectCreated: w,\n        failedIgnoreSuppression: V\n      }\n    }\n  };\n  return Ke(_e, { clock: b }), _e;\n}\nfunction Qt(e) {\n  const t = k({\n    handler: async ({ params: a, skipStale: o }) => {\n      for (const s of e)\n        try {\n          const i = await s.get({ params: a });\n          if (o && (i != null && i.stale))\n            continue;\n          if (i)\n            return i;\n        } catch (i) {\n          throw {\n            stopErrorPropagation: !1,\n            error: i\n          };\n        }\n      throw {\n        stopErrorPropagation: !1,\n        error: new Error(\"No data source returned data\")\n      };\n    }\n  }), r = k({\n    handler: async ({ params: a, result: o }) => {\n      await Promise.all(\n        e.map(U(\"set\")).filter(Boolean).map((s) => s({ params: a, result: o }))\n      );\n    }\n  }), n = k({\n    handler: async ({ params: a }) => {\n      await Promise.all(\n        e.map(U(\"unset\")).filter(Boolean).map((o) => o({ params: a }))\n      );\n    }\n  });\n  return {\n    retrieveDataFx: t,\n    notifyAboutNewValidDataFx: r,\n    notifyAboutDataInvalidationFx: n\n  };\n}\nfunction Jt(e) {\n  return \"responseMeta\" in e && typeof e.responseMeta == \"object\";\n}\nconst We = Symbol(\"Query\");\nfunction Ge(e) {\n  var t;\n  return ((t = e == null ? void 0 : e.__) == null ? void 0 : t.kind) === We;\n}\nconst Wt = Symbol(\"Farfetched node meta\"), Gt = Symbol(\"Farfetched links meta\");\nfunction Yt(e, t) {\n  return Fe({\n    meta: { [Wt]: e, [Gt]: t },\n    regional: !0\n  });\n}\nfunction de(e) {\n  const {\n    initialData: t,\n    contract: r,\n    mapData: n,\n    enabled: a,\n    validate: o,\n    name: s,\n    serialize: i,\n    sourced: l,\n    paramsAreMeaningless: y\n  } = e, g = t ?? null, f = Je({\n    name: s ?? Oe(),\n    kind: We,\n    serialize: se(i),\n    enabled: a,\n    meta: {\n      serialize: i,\n      initialData: g,\n      sid: Xt(x(null, { sid: \"dummy\" }))\n    },\n    contract: r,\n    validate: o,\n    mapData: n,\n    sourced: l,\n    paramsAreMeaningless: y\n  }), _ = $(), u = x(g, {\n    sid: `ff.${f.__.meta.name}.$data`,\n    name: `${f.__.meta.name}.$data`,\n    serialize: i,\n    skipVoid: !1\n  }), p = x(null, {\n    sid: `ff.${f.__.meta.name}.$error`,\n    name: `${f.__.meta.name}.$error`,\n    serialize: se(i),\n    skipVoid: !1\n  }), m = x(!0, {\n    sid: `ff.${f.__.meta.name}.$stale`,\n    name: `${f.__.meta.name}.$stale`,\n    serialize: se(i),\n    skipVoid: !1\n  });\n  c({\n    clock: f.finished.success,\n    fn: () => null,\n    target: p\n  }), c({\n    clock: f.finished.success,\n    fn: ({ result: b }) => b,\n    target: u\n  }), u.reset(f.finished.failure), c({\n    clock: f.finished.failure,\n    fn: ({ error: b }) => b,\n    target: p\n  }), c({\n    clock: f.finished.finally,\n    fn: ({ meta: b }) => b.stale,\n    target: m\n  }), c({\n    clock: f.__.lowLevelAPI.pushData,\n    target: [u, p.reinit]\n  }), c({\n    clock: f.__.lowLevelAPI.pushError,\n    target: [p, u.reinit]\n  });\n  const d = je({\n    clock: _,\n    until: f.$enabled\n  }), w = $(), { haveToStart: P, __: F } = J(\n    c({\n      clock: d,\n      source: { stale: m, latestParams: f.__.$latestParams },\n      fn: ({ stale: b, latestParams: S }, A) => ({\n        haveToStart: b || !Z(A, S),\n        params: A\n      })\n    }),\n    {\n      haveToStart: ({ haveToStart: b }) => b\n    }\n  );\n  c({\n    clock: F,\n    fn: () => null,\n    target: w\n  }), c({\n    clock: P,\n    fn: ({ params: b }) => b,\n    target: f.start\n  }), c({\n    clock: f.reset,\n    target: [u.reinit, p.reinit, m.reinit]\n  });\n  const I = {\n    data: u,\n    error: p,\n    stale: m,\n    pending: f.$pending,\n    start: f.start\n  }, N = () => I, C = ({\n    source: b,\n    mapParams: S\n  }) => {\n    const A = de(e);\n    return A.__.lowLevelAPI.dataSourceRetrieverFx.use(\n      T({\n        source: b,\n        mapParams: ({ params: M, ...V }, K) => ({\n          params: S ? S(M, K) : M,\n          ...V\n        }),\n        effect: f.__.lowLevelAPI.dataSourceRetrieverFx\n      })\n    ), A;\n  }, B = Yt(\n    { type: \"query\", name: e.name },\n    { $status: f.$status, $data: u, $error: p }\n  );\n  return pt(B, () => ({\n    refresh: _,\n    start: f.start,\n    reset: f.reset,\n    started: E(f.started),\n    $data: E(u),\n    $error: E(p),\n    $status: E(f.$status),\n    $idle: E(f.$idle),\n    $pending: E(f.$pending),\n    $succeeded: E(f.$succeeded),\n    $failed: E(f.$failed),\n    $finished: E(f.$finished),\n    $enabled: E(f.$enabled),\n    $stale: m,\n    aborted: E(f.aborted),\n    finished: {\n      success: E(f.finished.success),\n      failure: E(f.finished.failure),\n      finally: E(f.finished.finally),\n      skip: E(f.finished.skip)\n    },\n    __: {\n      ...f.__,\n      lowLevelAPI: { ...f.__.lowLevelAPI, refreshSkipDueToFreshness: w },\n      experimentalAPI: { attach: C }\n    },\n    \"@@unitShape\": N\n  }));\n}\nfunction Xt(e) {\n  const t = e.sid;\n  return t != null && t.includes(\"|\") ? t : null;\n}\nfunction Ye(e) {\n  const t = e;\n  if (q.effect(t.effect))\n    return t.effect;\n  if (typeof t.handler == \"function\")\n    return k(t.handler);\n  throw new Zt(\n    \"handler or effect must be passed to the config\"\n  );\n}\nclass Zt extends Error {\n  constructor(t) {\n    super(t);\n  }\n}\nfunction Or(e) {\n  const t = de({\n    initialData: e.initialData ?? null,\n    contract: e.contract ?? re,\n    mapData: e.mapData ?? (({ result: r }) => r),\n    enabled: e.enabled,\n    validate: e.validate,\n    name: e.name,\n    serialize: e.serialize\n  });\n  return t.__.executeFx.use(Ye(e)), t;\n}\nfunction Rr(e) {\n  const { source: t, target: r } = e, n = Ge(t), a = Array.isArray(r) ? r : [r], o = n ? [t] : Object.values(t), s = e == null ? void 0 : e.fn, i = e == null ? void 0 : e.filter, l = ce(o.map((u) => u.start)), y = ce(\n    o.map((u) => u.finished.success)\n  ), g = le({\n    stores: o.map((u) => u.$data),\n    predicate: (u) => u !== null\n  }), f = n ? t.$data : O(ve(t, (u) => u.$data)), _ = x(null, {\n    serialize: \"ignore\",\n    name: \"ff.$allParentParamsDictionary\",\n    sid: \"ff.$allParentParamsDictionary\",\n    skipVoid: !1\n  });\n  if (n)\n    c({\n      clock: t.finished.success,\n      fn: ({ params: u }) => u,\n      target: _\n    });\n  else\n    for (const [u, p] of Object.entries(\n      ve(t, (m) => m.finished.success)\n    ))\n      c({\n        clock: p,\n        source: _,\n        fn: (m, { params: d }) => ({\n          ...m,\n          [u]: d\n        }),\n        target: _\n      });\n  c({\n    clock: l,\n    fn() {\n      return !0;\n    },\n    target: a.map((u) => u.$stale)\n  }), c({\n    clock: je({\n      clock: y,\n      until: g\n    }),\n    source: {\n      data: f,\n      params: _\n    },\n    filter({ data: u, params: p }) {\n      return (i == null ? void 0 : i(\n        n ? { result: u, params: p } : be({ result: u, params: p })\n      )) ?? !0;\n    },\n    fn({ data: u, params: p }) {\n      const m = s == null ? void 0 : s(\n        n ? { result: u, params: p } : be({ result: u, params: p })\n      );\n      return m == null ? void 0 : m.params;\n    },\n    target: a.map((u) => u.start)\n  });\n}\nfunction Xe(...e) {\n  const t = {};\n  for (const r of e)\n    if (typeof r == \"object\")\n      for (const [n, a] of Object.entries(r || {})) {\n        const o = pe(a);\n        o !== null && (t[n] ? t[n] = [t[n], o].flat() : t[n] = o);\n      }\n  return t;\n}\nfunction er(...e) {\n  const t = [];\n  for (const r of e) {\n    if (!r)\n      continue;\n    let n;\n    typeof r != \"string\" ? n = Ze(r).toString() : n = r, t.push(n);\n  }\n  return t.join(\"&\");\n}\nfunction tr(e) {\n  const t = new Headers();\n  for (const [r, n] of Object.entries(e)) {\n    const a = pe(n);\n    if (Array.isArray(a))\n      for (const o of a)\n        t.append(r, o);\n    else\n      a !== null && t.append(r, a);\n  }\n  return t;\n}\nfunction rr(e, t) {\n  let r;\n  e.startsWith(\"/\") && (r = window.location.origin);\n  let n, a;\n  typeof t == \"string\" ? a = t : a = Ze(t).toString(), a ? n = `${e}?${a}` : n = e;\n  const o = [n, r].filter(Boolean);\n  try {\n    return new URL(...o);\n  } catch {\n    throw ie({\n      reason: \"Invalid URL\",\n      validationErrors: [`\"${n}\" is not valid URL`]\n    });\n  }\n}\nfunction Ze(e) {\n  const t = new URLSearchParams();\n  for (const [r, n] of Object.entries(e)) {\n    const a = pe(n);\n    if (Array.isArray(a))\n      for (const o of a)\n        t.append(r, o);\n    else\n      a !== null && t.append(r, a);\n  }\n  return t;\n}\nfunction pe(e) {\n  return typeof e == \"number\" || typeof e == \"boolean\" ? e.toString() : e ?? null;\n}\nconst nr = k({\n  sid: \"ff.fetchFx\",\n  handler: globalThis.fetch\n}), ar = k({\n  handler: async (e) => {\n    const t = await nr(e).catch((r) => {\n      throw Tt({\n        reason: (r == null ? void 0 : r.message) ?? null,\n        cause: r\n      });\n    });\n    if (!t.ok)\n      throw Be({\n        status: t.status,\n        statusText: t.statusText,\n        response: await t.text().catch(() => null) ?? null\n      });\n    return t;\n  },\n  sid: \"ff.requestFx\"\n});\nfunction sr(e) {\n  const t = k(e.response.extract), r = k(\n    async ({\n      url: n,\n      method: a,\n      query: o,\n      headers: s,\n      credentials: i,\n      body: l,\n      abortController: y\n    }) => {\n      const g = l ? e.request.mapBody(l) : null, f = new Request(rr(n, o), {\n        method: a,\n        headers: tr(s),\n        credentials: i,\n        body: g,\n        signal: y == null ? void 0 : y.signal\n      }), _ = await ar(f).catch((m) => {\n        throw e.response.transformError ? e.response.transformError(m) : m;\n      }), u = _.clone(), p = await t(_).catch(async (m) => {\n        throw It({\n          response: await u.text(),\n          reason: (m == null ? void 0 : m.message) ?? null\n        });\n      });\n      if (e.response.status) {\n        const m = Array.isArray(e.response.status.expected) ? e.response.status.expected : [e.response.status.expected];\n        if (!m.includes(_.status))\n          throw ee({\n            validationErrors: [\n              `Expected response status has to be one of [${m.join(\n                \", \"\n              )}], got ${_.status}`\n            ],\n            response: p\n          });\n      }\n      return { result: p, meta: { headers: _.headers } };\n    }\n  );\n  return T({\n    source: {\n      url: R(e.request.url),\n      method: R(e.request.method),\n      query: R(e.request.query),\n      headers: R(e.request.headers),\n      credentials: R(e.request.credentials),\n      body: R(e.request.body)\n    },\n    mapParams(n, a) {\n      const o = a.url ?? // @ts-expect-error TS cannot infer type correctly, but there is always field in staticConfig or dynamicConfig\n      n.url, s = a.credentials ?? // @ts-expect-error TS cannot infer type correctly, but there is always field in staticConfig or dynamicConfig\n      n.credentials, i = a.body ?? // @ts-expect-error TS cannot infer type correctly, but there is always field in staticConfig or dynamicConfig\n      n.body, l = er(a.query, n.query), y = Xe(a.headers, n.headers), { method: g } = a, { abortController: f } = n;\n      return {\n        url: o,\n        method: g,\n        // TODO: fix type inference here\n        query: l,\n        headers: y,\n        credentials: s,\n        body: i,\n        abortController: f\n      };\n    },\n    effect: r\n  });\n}\nfunction et(e) {\n  var n;\n  const t = O(\n    {\n      method: R(e.request.method),\n      headers: R(e.request.headers)\n    },\n    ({ method: a, headers: o }) => (\n      // reversed merge order to allow any modifications in the user code\n      Xe(\n        {\n          Accept: \"application/json\",\n          \"Content-Type\": [\"GET\", \"HEAD\"].includes(a) ? void 0 : \"application/json\"\n        },\n        o\n      )\n    )\n  );\n  return sr({\n    ...e,\n    request: {\n      ...e.request,\n      headers: t,\n      // Serialize body to JSON-string\n      mapBody: (a) => JSON.stringify(a)\n    },\n    response: {\n      extract: async (a) => await or(a) ? null : a.json(),\n      transformError: (a) => {\n        if (!He({ error: a }))\n          return a;\n        const o = a;\n        if (typeof o.response != \"string\")\n          return o;\n        try {\n          const s = JSON.parse(o.response);\n          return Be({\n            status: o.status,\n            statusText: o.statusText,\n            response: s\n          });\n        } catch {\n          return o;\n        }\n      },\n      status: (n = e.response) == null ? void 0 : n.status\n    }\n  });\n}\nasync function or(e) {\n  return !e.body || e.headers.get(\"Content-Length\") === \"0\" || (await e.clone().text()).length === 0;\n}\nfunction qr(e) {\n  const t = e.request.credentials, r = et({\n    request: {\n      method: e.request.method,\n      credentials: t\n    }\n  }), n = de({\n    initialData: e.initialData,\n    contract: e.response.contract ?? re,\n    mapData: e.response.mapData ?? (({ result: s }) => s),\n    validate: e.response.validate,\n    enabled: e.enabled,\n    name: e.name,\n    serialize: e.serialize,\n    sourced: [\n      e.request.url,\n      e.request.body,\n      e.request.headers,\n      e.request.query\n    ],\n    paramsAreMeaningless: !0\n  }), a = k(async (s) => {\n    const i = new AbortController();\n    Ue(() => i.abort());\n    const { result: l, meta: y } = await r({ ...s, abortController: i });\n    return { [ae]: l, [ne]: y };\n  });\n  n.__.executeFx.use(\n    T({\n      source: {\n        partialUrl: D({\n          field: e.request.url\n        }),\n        partialBody: D({\n          field: e.request.body\n        }),\n        partialHeaders: D({\n          field: e.request.headers\n        }),\n        partialQuery: D({\n          field: e.request.query\n        })\n      },\n      mapParams(s, { partialUrl: i, partialBody: l, partialHeaders: y, partialQuery: g }) {\n        return {\n          url: i(s),\n          body: l(s),\n          headers: y(s),\n          query: g(s)\n        };\n      },\n      effect: a\n    })\n  );\n  const o = {\n    ...n,\n    __: { ...n.__, executeFx: a }\n  };\n  return e.concurrency && (console.error(\n    \"concurrency field in createJsonQuery is deprecated, please use concurrency operator instead: https://farfetched.pages.dev/adr/concurrency\"\n  ), o.__.meta.flags.concurrencyFieldUsed = !0), setTimeout(() => {\n    var s, i;\n    o.__.meta.flags.concurrencyOperatorUsed || (console.error(\n      \"Please apply concurrency operator to the query, read more: https://farfetched.pages.dev/adr/concurrency\"\n    ), Ve(o, {\n      strategy: ((s = e.concurrency) == null ? void 0 : s.strategy) ?? \"TAKE_LATEST\",\n      abortAll: (i = e.concurrency) == null ? void 0 : i.abort\n    }));\n  }), o;\n}\nconst tt = Symbol(\"Mutation\");\nfunction cr(e) {\n  var t;\n  return ((t = e == null ? void 0 : e.__) == null ? void 0 : t.kind) === tt;\n}\nfunction me(e) {\n  const { name: t, enabled: r, contract: n, validate: a, mapData: o } = e, s = Je({\n    name: t ?? Oe(),\n    serialize: \"ignore\",\n    enabled: r,\n    kind: tt,\n    meta: null,\n    contract: n,\n    validate: a,\n    mapData: o\n  }), i = {\n    pending: s.$pending,\n    start: s.start,\n    reset: s.reset\n  }, l = () => i, y = ({\n    source: g,\n    mapParams: f\n  }) => {\n    const _ = me(e);\n    return _.__.lowLevelAPI.dataSourceRetrieverFx.use(\n      T({\n        source: g,\n        mapParams: ({ params: u, ...p }, m) => ({\n          params: f ? f(u, m) : u,\n          ...p\n        }),\n        effect: s.__.lowLevelAPI.dataSourceRetrieverFx\n      })\n    ), _;\n  };\n  return {\n    start: s.start,\n    reset: s.reset,\n    started: E(s.started),\n    aborted: E(s.aborted),\n    $status: E(s.$status),\n    $idle: E(s.$idle),\n    $pending: E(s.$pending),\n    $succeeded: E(s.$succeeded),\n    $failed: E(s.$failed),\n    $finished: E(s.$finished),\n    $enabled: E(s.$enabled),\n    finished: {\n      success: E(s.finished.success),\n      failure: E(s.finished.failure),\n      finally: E(s.finished.finally),\n      skip: E(s.finished.skip)\n    },\n    __: { ...s.__, experimentalAPI: { attach: y } },\n    \"@@unitShape\": l\n  };\n}\nfunction Nr(e) {\n  const t = me({\n    name: e.name,\n    enabled: e.enabled,\n    contract: e.contract ?? re,\n    mapData: ({ result: r }) => r\n  });\n  return t.__.executeFx.use(Ye(e)), t;\n}\nfunction Lr(e) {\n  const t = e.request.credentials, r = et({\n    request: { method: e.request.method, credentials: t },\n    response: { status: e.response.status }\n  }), n = me({\n    contract: e.response.contract ?? re,\n    mapData: e.response.mapData ?? (({ result: s }) => s),\n    validate: e.response.validate,\n    enabled: e.enabled,\n    name: e.name\n  }), a = k(async (s) => {\n    const i = new AbortController();\n    Ue(() => i.abort());\n    const { result: l, meta: y } = await r({ ...s, abortController: i });\n    return { [ae]: l, [ne]: y };\n  });\n  n.__.executeFx.use(\n    T({\n      source: {\n        partialUrl: D({\n          field: e.request.url\n        }),\n        partialBody: D({\n          field: e.request.body\n        }),\n        partialHeaders: D({\n          field: e.request.headers\n        }),\n        partialQuery: D({\n          field: e.request.query\n        })\n      },\n      mapParams(s, { partialUrl: i, partialBody: l, partialHeaders: y, partialQuery: g }) {\n        return {\n          url: i(s),\n          body: l(s),\n          headers: y(s),\n          query: g(s)\n        };\n      },\n      effect: a\n    })\n  );\n  const o = {\n    ...n,\n    __: { ...n.__, executeFx: a }\n  };\n  return e.concurrency && (console.error(\n    \"concurrency field in createJsonMutation is deprecated, please use concurrency operator instead: https://farfetched.pages.dev/adr/concurrency\"\n  ), o.__.meta.flags.concurrencyFieldUsed = !0), e.concurrency && setTimeout(() => {\n    var s, i;\n    o.__.meta.flags.concurrencyOperatorUsed || Ve(o, {\n      strategy: ((s = e.concurrency) == null ? void 0 : s.strategy) ?? \"TAKE_EVERY\",\n      abortAll: (i = e.concurrency) == null ? void 0 : i.abort\n    });\n  }), o;\n}\nconst ir = [\n  \"ms\",\n  \"milli\",\n  \"millisecond\",\n  \"milliseconds\"\n], lr = [\"s\", \"sec\", \"secs\", \"second\", \"seconds\"], ur = [\"m\", \"min\", \"mins\", \"minute\", \"minutes\"], fr = [\"h\", \"hr\", \"hrs\", \"hour\", \"hours\"];\nfunction W(e) {\n  if (typeof e == \"number\")\n    return e;\n  let t = 0;\n  for (const r of e.split(\" \"))\n    switch (!0) {\n      case Y(r, ir):\n        t += X(r);\n        break;\n      case Y(r, lr):\n        t += X(r) * 1e3;\n        break;\n      case Y(r, ur):\n        t += X(r) * 6e4;\n        break;\n      case Y(r, fr):\n        t += X(r) * 36e5;\n        break;\n    }\n  return t;\n}\nfunction Y(e, t) {\n  return t.includes(dr(e));\n}\nfunction dr(e) {\n  return e.replace(/[0-9.]/g, \"\");\n}\nfunction X(e) {\n  return e.includes(\".\") ? parseFloat(e) : parseInt(e);\n}\nfunction Mr(e, {\n  times: t,\n  delay: r,\n  filter: n,\n  mapParams: a,\n  ...o\n}) {\n  const s = o.supressIntermediateErrors ?? !0, i = R(t), l = x(1, {\n    serialize: \"ignore\",\n    name: \"ff.$attempt\",\n    sid: \"ff.$attempt\"\n  }), y = O({\n    attempt: l\n  }), g = O(\n    l,\n    i,\n    (d, w) => s && d <= w\n  ), f = $(), _ = $(), u = D({\n    field: n ?? !0\n  }), { planNextAttempt: p, __: m } = J(\n    c({\n      clock: f,\n      source: {\n        maxAttempts: i,\n        attempt: l,\n        partialFilter: u\n      },\n      filter: ({ partialFilter: d }, w) => d(w),\n      fn: ({ attempt: d, maxAttempts: w }, { params: P, error: F, meta: I }) => ({\n        params: P,\n        error: F,\n        meta: { ...I, attempt: d, maxAttempts: w }\n      })\n    }),\n    { planNextAttempt: ({ meta: d }) => d.attempt <= d.maxAttempts }\n  );\n  if (c({\n    clock: Te({\n      clock: c({\n        clock: p,\n        source: {\n          partialMapper: D({\n            field: a ?? (({ params: d }) => d)\n          })\n        },\n        fn: ({ partialMapper: d }, w) => d(w)\n      }),\n      timeout: O(\n        {\n          partialTimeout: D({\n            field: r\n          }),\n          meta: y\n        },\n        ({ partialTimeout: d, meta: w }) => W(d(w))\n      )\n    }),\n    fn: (d) => ({\n      params: d,\n      meta: { stopErrorPropagation: !1, stale: !0 }\n    }),\n    target: [_, e.__.lowLevelAPI.startWithMeta]\n  }), l.on(_, (d) => d + 1).reset([e.finished.success, e.start]), o.otherwise && c({ clock: m, target: o.otherwise }), s) {\n    const d = e.__.lowLevelAPI.dataSourceRetrieverFx.use.getCurrent();\n    c({\n      clock: e.__.lowLevelAPI.failedIgnoreSuppression,\n      target: f\n    }), e.__.lowLevelAPI.dataSourceRetrieverFx.use(\n      T({\n        source: { supressError: g, partialFilter: u },\n        mapParams: (w, { supressError: P, partialFilter: F }) => ({\n          ...w,\n          supressError: P,\n          partialFilter: F\n        }),\n        effect: k(async ({ supressError: w, partialFilter: P, ...F }) => {\n          const I = Ie(f, { safe: !0 });\n          try {\n            return { ...await d(F), stopErrorPropagation: w };\n          } catch (N) {\n            const C = {\n              params: F.params,\n              error: N.error,\n              meta: F.meta\n            };\n            throw (\n              /*\n               * If filter returns false, this fail is not supposed to be retried\n               * so we should not suppress this error in any case.\n               *\n               * If filter returns is true, we should suppress this error only if\n               * supressError is true.\n               */\n              P(C) && w ? (I(C), { error: N.error, stopErrorPropagation: !0 }) : N\n            );\n          }\n        })\n      })\n    );\n  }\n  c({ clock: e.finished.failure, target: f });\n}\nconst rt = {\n  randomize: { spread: 0 }\n};\nfunction zr(e, t = rt) {\n  return function({ attempt: r }) {\n    return e * r + nt(t);\n  };\n}\nfunction Cr(e, t = rt) {\n  return function({ attempt: r }) {\n    return e ** r + nt(t);\n  };\n}\nfunction nt({ randomize: e }) {\n  const { spread: t } = e;\n  return kt({ min: -t, max: t });\n}\nfunction Br(e, t) {\n  const r = T({\n    source: R(t.after).map(W),\n    effect(n, a) {\n      return new Promise((o) => {\n        var l;\n        const s = setTimeout(() => {\n          a.abort(Ft({ timeout: n })), o();\n        }, n), i = () => {\n          clearTimeout(s), o();\n        };\n        (l = a.promise) == null || l.then(i, i);\n      });\n    }\n  });\n  c({\n    clock: e.__.lowLevelAPI.callObjectCreated,\n    target: r\n  });\n}\nfunction Hr(e, {\n  on: t,\n  by: r\n}) {\n  const n = pr(e), a = $(), o = $();\n  J({\n    source: c({\n      clock: t.finished.success,\n      source: {\n        partialRule: D({\n          field: r.success\n        }),\n        queryState: n\n      },\n      fn: ({ partialRule: l, queryState: y }, g) => l({\n        query: y,\n        mutation: g\n      })\n    }),\n    match: {\n      fillData: (l) => we(l.result)\n    },\n    cases: { fillData: a, __: o }\n  }), r.failure && J({\n    source: c({\n      clock: t.finished.failure,\n      source: {\n        partialRule: D({\n          field: r.failure\n        }),\n        queryState: n\n      },\n      fn: ({ partialRule: l, queryState: y }, g) => l({\n        query: y,\n        mutation: g\n      })\n    }),\n    match: {\n      fillData: (l) => we(l.result)\n    },\n    cases: { fillData: a, __: o }\n  }), c({\n    clock: a,\n    fn: ({ result: l }) => l,\n    target: e.__.lowLevelAPI.pushData\n  }), c({\n    clock: o,\n    fn: ({ error: l }) => l,\n    target: e.__.lowLevelAPI.pushError\n  });\n  const { shouldRefetch: s, __: i } = J(\n    ce([a, o]).map(({ refetch: l }) => l),\n    {\n      shouldRefetch: (l) => !!l\n    }\n  );\n  c({\n    clock: s,\n    source: n,\n    filter: (l, y) => typeof y == \"object\" && \"params\" in y || l && \"params\" in l,\n    fn: (l, y) => typeof y == \"object\" && \"params\" in y ? { params: y.params, refresh: !0 } : { params: l == null ? void 0 : l.params, refresh: !0 },\n    target: [e.__.lowLevelAPI.revalidate, e.$stale.reinit]\n  }), c({\n    clock: i,\n    source: n,\n    filter: (l) => l && \"params\" in l,\n    fn: (l) => ({\n      params: l.params,\n      refresh: !1\n    }),\n    target: e.__.lowLevelAPI.revalidate\n  });\n}\nfunction pr(e) {\n  return O(\n    {\n      idle: e.$idle,\n      result: e.$data,\n      params: e.__.$latestParams,\n      error: e.$error,\n      failed: e.$failed\n    },\n    ({ idle: t, result: r, params: n, error: a, failed: o }) => r == null && a == null ? null : t ? { result: r } : o ? { error: a, params: n } : { result: r, params: n }\n  );\n}\nfunction Ur(e, t) {\n  var a;\n  console.error(\n    \"attachOperation is deprecated since 0.12, please read the migration guide: https://farfetched.pages.dev/adr/attach_operation_deprecation.html\"\n  );\n  const { source: r, mapParams: n } = t ?? {};\n  return (a = e.__.experimentalAPI) == null ? void 0 : a.attach({\n    source: r ?? x(null, {\n      serialize: \"ignore\"\n    }),\n    mapParams: n ?? ((o) => o)\n  });\n}\nfunction he(e) {\n  const t = x(e, {\n    serialize: \"ignore\",\n    name: \"ff.$cacheInstance\",\n    sid: \"ff.$cacheInstance\"\n  });\n  return { ...e, __: { $instance: t } };\n}\nfunction at({\n  adapter: e,\n  options: t,\n  events: r\n}) {\n  t != null && t.hit && c({\n    clock: e.get.done,\n    filter: ({ result: n }) => n !== null,\n    fn: ({ params: n }) => ({ key: n.key }),\n    target: t.hit\n  }), t != null && t.miss && c({\n    clock: e.get.done,\n    filter: ({ result: n }) => n === null,\n    fn: ({ params: n }) => ({ key: n.key }),\n    target: t.miss\n  }), t != null && t.expired && (r != null && r.itemExpired) && c({\n    clock: r.itemExpired,\n    fn: ({ key: n }) => ({ key: n }),\n    target: t.expired\n  }), t != null && t.evicted && (r != null && r.itemEvicted) && c({\n    clock: r.itemEvicted,\n    target: t.evicted\n  });\n}\nfunction mr(e) {\n  const { maxEntries: t, maxAge: r, observability: n } = e ?? {};\n  let a = {};\n  const o = $(), s = $(), i = $(), l = $(), y = $();\n  y.watch(() => {\n    a = {};\n  });\n  const g = $t({ clock: o }), f = c({\n    clock: o,\n    source: { now: g },\n    fn: ({ now: u }, { key: p, value: m }) => hr(\n      a,\n      { key: p, entry: { value: m, cachedAt: u } },\n      t\n    )\n  });\n  if (f.watch(({ next: u }) => {\n    a = u;\n  }), c({\n    clock: f,\n    filter: ({ evicted: u }) => !!u,\n    fn: ({ evicted: u }) => ({ key: u }),\n    target: l\n  }), s.watch(({ key: u }) => {\n    const { [u]: p, ...m } = a;\n    a = m;\n  }), r) {\n    const u = W(r);\n    o.watch((p) => {\n      const m = Ie(i, { safe: !0 });\n      setTimeout(() => m(p), u);\n    }), c({\n      clock: i,\n      fn: ({ key: p }) => ({ key: p }),\n      target: s\n    });\n  }\n  const _ = {\n    get: k(({ key: u }) => {\n      const p = a[u] ?? null;\n      if (!p)\n        return null;\n      if (r) {\n        const m = (p == null ? void 0 : p.cachedAt) + W(r);\n        if (Date.now() >= m)\n          return s({ key: u }), null;\n      }\n      return p;\n    }),\n    set: k(o),\n    unset: k(s),\n    purge: y\n  };\n  return at({\n    adapter: _,\n    options: n,\n    events: { itemExpired: i, itemEvicted: l }\n  }), he(_);\n}\nfunction hr(e, { key: t, entry: r }, n) {\n  if (n === void 0)\n    return { next: { ...e, [t]: r }, evicted: null };\n  const a = Object.keys(e);\n  if (a.length < n)\n    return { next: { ...e, [t]: r }, evicted: null };\n  const [o] = a, { [o]: s, ...i } = e;\n  return { next: { ...i, [t]: r }, evicted: o };\n}\nfunction yr(e) {\n  let t = 0, r = 0;\n  for (; r < e.length; )\n    t = (t << 5) - t + e.charCodeAt(r++) | 0;\n  return t.toString(36);\n}\nfunction st(e) {\n  const t = /* @__PURE__ */ new Set();\n  function r(n) {\n    if (n === void 0)\n      return;\n    if (n === null)\n      return \"null\";\n    if (typeof n == \"number\")\n      return isFinite(n) ? `${n}` : \"null\";\n    if (typeof n == \"function\")\n      throw new TypeError(\"Can't serialize function\");\n    if (typeof n != \"object\")\n      return JSON.stringify(n);\n    if (t.has(n))\n      throw new TypeError(\"Can't serialize cyclic structure\");\n    if (t.add(n), Array.isArray(n)) {\n      const o = n.map((s) => r(s) || \"null\").join(\",\");\n      return t.delete(n), `[${o}]`;\n    }\n    const a = Object.keys(n).sort().map((o) => {\n      const s = r(n[o]);\n      return s ? `${r(o)}:${s}` : \"\";\n    }).filter(Boolean).join(\",\");\n    return t.delete(n), `{${a}}`;\n  }\n  return r(e);\n}\nfunction gr({\n  sid: e,\n  params: t = null,\n  sources: r\n}) {\n  try {\n    return st({ params: t, sources: r, sid: e }) ?? null;\n  } catch {\n    return null;\n  }\n}\nfunction $r({\n  sid: e,\n  params: t = null,\n  sources: r\n}) {\n  try {\n    const n = st({ params: t, sources: r, sid: e });\n    return yr(n);\n  } catch {\n    return null;\n  }\n}\nfunction _r(e) {\n  const t = kr(e);\n  if (t)\n    return t;\n  const r = vr(e);\n  if (r)\n    return r;\n  throw new Error(\n    \"Query does not have sid or uniq name, which is required for caching, read more https://effector.dev/en/explanation/sids/\"\n  );\n}\nfunction kr(e) {\n  return e.__.meta.sid ?? null;\n}\nconst Pe = /* @__PURE__ */ new Set();\nfunction vr(e) {\n  const t = e.__.meta.name;\n  return Pe.has(t) ? null : (Pe.add(t), t);\n}\nfunction Vr(e, t) {\n  const {\n    adapter: r,\n    staleAfter: n,\n    purge: a,\n    humanReadableKeys: o\n  } = {\n    adapter: (t == null ? void 0 : t.adapter) ?? mr(),\n    humanReadableKeys: !1,\n    ...t\n  }, s = o ? gr : $r, i = _r(e), l = e.__.lowLevelAPI.sourced.map(ht), y = k(async (p) => Promise.all(l.map((m) => m(p)))), g = k(async ({ instance: p, params: m }) => {\n    const d = await y(m), w = s({\n      sid: i,\n      params: e.__.lowLevelAPI.paramsAreMeaningless ? null : m,\n      sources: d\n    });\n    w && await p.unset({ key: w });\n  }), f = k(async ({ instance: p, params: m, result: d }) => {\n    const w = await y(m), P = s({\n      sid: i,\n      params: e.__.lowLevelAPI.paramsAreMeaningless ? null : m,\n      sources: w\n    });\n    P && await p.set({ key: P, value: d });\n  }), _ = k(async ({ params: p, instance: m }) => {\n    const d = await y(p), w = s({\n      sid: i,\n      params: e.__.lowLevelAPI.paramsAreMeaningless ? null : p,\n      sources: d\n    });\n    if (!w)\n      return null;\n    const P = await m.get({ key: w });\n    if (!P)\n      return null;\n    const F = n ? P.cachedAt + W(n) <= Date.now() : !0;\n    return { result: P.value, stale: F };\n  }), u = {\n    name: \"cache\",\n    get: T({\n      source: {\n        instance: r.__.$instance\n      },\n      mapParams: ({ params: p }, { instance: m }) => ({\n        params: p,\n        instance: m\n      }),\n      effect: _\n    }),\n    set: T({\n      source: {\n        instance: r.__.$instance\n      },\n      mapParams: ({ params: p, result: m }, { instance: d }) => ({\n        params: p,\n        result: m,\n        instance: d\n      }),\n      effect: f\n    }),\n    unset: T({\n      source: {\n        instance: r.__.$instance\n      },\n      mapParams: ({ params: p }, { instance: m }) => ({\n        instance: m,\n        params: p\n      }),\n      effect: g\n    })\n  };\n  e.__.lowLevelAPI.dataSources.unshift(u), a && c({\n    clock: a,\n    source: { instance: r.__.$instance },\n    target: k(\n      ({ instance: p }) => p.purge()\n    )\n  });\n}\nconst oe = \"__farfetched_meta__\";\nfunction ot(e) {\n  const { storage: t, observability: r, maxAge: n, maxEntries: a, serialize: o } = e;\n  function s() {\n    const d = k(async (b) => {\n      const S = await p(b);\n      if (!S)\n        return null;\n      try {\n        const A = JSON.parse(S);\n        return {\n          ...A,\n          value: o != null && o.read ? o.read(A.value) : A.value\n        };\n      } catch {\n        return null;\n      }\n    }), w = k(\n      async ({ key: b, value: S }) => {\n        const A = JSON.stringify({\n          value: o != null && o.write ? o.write(S) : S,\n          timestamp: Date.now()\n        });\n        _.addKey({ key: b }), await u({ key: b, value: A });\n      }\n    ), P = k(async (b) => {\n      _.removeKey({ key: b }), await m(b);\n    }), F = $(), I = $(), N = $(), C = k(\n      async (b) => Promise.all(b.map(P))\n    );\n    c({\n      clock: N,\n      source: _.$meta,\n      fn: (b) => (b == null ? void 0 : b.keys) ?? [],\n      target: C\n    }), n && c({\n      clock: Te({\n        clock: c({\n          clock: u.done,\n          filter: ({ params: b }) => b.key !== oe\n        }),\n        timeout: W(n)\n      }),\n      fn: U(\"params\"),\n      target: [F, P]\n    });\n    const B = {\n      get: k(async ({ key: b }) => {\n        const S = await d(b);\n        if (!S)\n          return null;\n        if (n) {\n          const A = (S == null ? void 0 : S.timestamp) + W(n);\n          if (Date.now() >= A)\n            return F({ key: b, value: S.value }), await P(b), null;\n        }\n        return { value: S.value, cachedAt: S.timestamp };\n      }),\n      set: k(\n        async ({ key: b, value: S }) => {\n          var V, K;\n          const A = await l(), M = ((V = A == null ? void 0 : A.keys) == null ? void 0 : V.length) ?? 0;\n          if (a && M >= a) {\n            const L = (K = A == null ? void 0 : A.keys) == null ? void 0 : K.slice(0, M - a + 1);\n            for (const G of L ?? [])\n              I({ key: G }), await P(G);\n          }\n          await w({ key: b, value: S });\n        }\n      ),\n      unset: k(async ({ key: b }) => {\n        await P(b);\n      }),\n      purge: N\n    };\n    return at({\n      adapter: B,\n      options: r,\n      events: { itemExpired: F, itemEvicted: I }\n    }), he(B);\n  }\n  const i = x(null, {\n    serialize: \"ignore\",\n    name: \"ff.browserStorage.$meta\",\n    sid: \"ff.browserStorage.$meta\"\n  }), l = k(async () => {\n    const d = await p(oe);\n    if (!d)\n      return null;\n    try {\n      return JSON.parse(d);\n    } catch {\n      return null;\n    }\n  }), y = k(\n    (d) => u({ key: oe, value: JSON.stringify(d) })\n  ), g = $(), f = $(), _ = {\n    $meta: i,\n    addKey: g,\n    removeKey: f\n  };\n  c({ clock: l.doneData, target: i }), c({ clock: i, filter: Boolean, target: y }), c({\n    clock: g,\n    source: i,\n    fn: (d, { key: w }) => {\n      const P = (d == null ? void 0 : d.keys) ?? [];\n      return P.includes(w) ? d : { ...d, keys: [...P, w] };\n    },\n    target: i\n  }), c({\n    clock: f,\n    source: i,\n    fn: (d, { key: w }) => {\n      var P;\n      return {\n        ...d,\n        keys: ((P = d == null ? void 0 : d.keys) == null ? void 0 : P.filter((F) => F !== w)) ?? []\n      };\n    },\n    target: i\n  });\n  const u = k((d) => {\n    t().setItem(d.key, d.value);\n  }), p = k((d) => t().getItem(d)), m = k((d) => t().removeItem(d));\n  return s();\n}\nfunction Kr(e) {\n  return ot({ storage: () => localStorage, ...e });\n}\nfunction Qr(e) {\n  return ot({\n    storage: () => sessionStorage,\n    ...e\n  });\n}\nfunction Jr() {\n  return he({\n    get: k(() => null),\n    set: k(() => {\n    }),\n    purge: $(),\n    unset: k()\n  });\n}\nfunction Wr() {\n  return $();\n}\nfunction Gr(e, t) {\n  const r = [], [n, a] = At(t.triggers ?? [], q.event);\n  r.push(...n);\n  const o = [e.$enabled];\n  t.enabled !== void 0 && o.push(t.enabled);\n  const s = le({\n    predicate: Boolean,\n    stores: o\n  });\n  if (a.length > 0) {\n    const l = a.map(\n      (_) => _[\"@@trigger\"]()\n    ), y = x(!1, {\n      serialize: \"ignore\",\n      name: \"ff.$alreadySetup\",\n      sid: \"ff.$alreadySetup\"\n    }), { setup: g, teardown: f } = mt(y, {\n      setup: () => !0,\n      teardown: () => !1\n    });\n    c({\n      clock: [\n        e.finished.success,\n        c({ clock: s.updates, filter: s })\n      ],\n      filter: H(y),\n      target: [...l.map(U(\"setup\")), g]\n    }), c({\n      clock: s.updates,\n      filter: De(y, H(s)),\n      target: [...l.map(U(\"teardown\")), f]\n    }), r.push(...l.map(U(\"fired\")));\n  }\n  if (t.automatically) {\n    const l = e.finished.finally.map(U(\"params\")), y = x([], {\n      serialize: \"ignore\",\n      name: \"ff.$previousSources\",\n      sid: \"ff.$previousSources\"\n    }), g = O(\n      e.__.lowLevelAPI.sourced.map(\n        (_) => D({ field: _ })\n      )\n    );\n    c({\n      clock: l,\n      source: g,\n      fn: (_, u) => _.map((p) => p(u)),\n      filter: s,\n      target: y\n    });\n    const f = x(null, {\n      serialize: \"ignore\",\n      name: \"ff.$nextSources\",\n      sid: \"ff.$nextSources\"\n    });\n    c({\n      // @ts-expect-error I have no idea\n      clock: e.__.lowLevelAPI.sourced.map(yt).filter(q.store),\n      source: {\n        latestParams: e.__.$latestParams,\n        partialSources: g\n      },\n      filter: H(e.$idle),\n      fn: ({ latestParams: _, partialSources: u }) => u.map((p) => p(_)),\n      target: f\n    }), r.push(\n      c({\n        clock: [f.updates, s.updates.filter({ fn: Boolean })],\n        source: [f, y],\n        filter: ([_, u]) => !Z(_, u)\n      })\n    );\n  }\n  const i = c({ clock: r, filter: s });\n  c({\n    clock: i,\n    filter: H(e.$idle),\n    fn: () => !0,\n    target: e.$stale\n  }), c({\n    clock: _t(i),\n    source: e.__.$latestParams,\n    filter: H(e.$idle),\n    target: e.refresh\n  });\n}\nfunction br(e, { barrier: t }) {\n  if (Array.isArray(e))\n    for (const r of e)\n      br(r, { barrier: t });\n  else {\n    c({ clock: e.started, target: t.__.touch }), c({\n      clock: e.finished.failure,\n      target: t.__.operationFailed\n    }), c({\n      clock: t.activated,\n      filter: e.$failed,\n      source: e.__.$latestParams,\n      fn: (n) => ({\n        params: n,\n        meta: { stopErrorPropagation: !1, stale: !1 }\n      }),\n      target: e.__.lowLevelAPI.startWithMeta\n    });\n    const r = T({\n      source: { mutex: t.__.$mutex, active: t.$active },\n      async effect({ mutex: n }) {\n        return await (n == null ? void 0 : n.waitForUnlock()), null;\n      }\n    });\n    e.__.lowLevelAPI.dataSources.unshift({\n      name: \"barrier_blocker\",\n      get: r\n    });\n  }\n}\nfunction Yr({\n  active: e,\n  perform: t,\n  activateOn: r,\n  deactivateOn: n\n}) {\n  const a = $(), o = $(), s = $(), i = $(), l = $(), y = $(), g = Ar(t ?? []), f = $(), _ = x(!1, {\n    sid: \"barrier.$forceDeactivated\",\n    name: \"barrier.$forceDeactivated\",\n    serialize: \"ignore\"\n  }).on(f, () => !0);\n  let u;\n  if (e)\n    u = e;\n  else if (q.event(r) && q.event(n))\n    u = x(!1, {\n      sid: \"barrier.$active\",\n      name: \"barrier.$active\"\n    }).on(r, () => !0).on(n, () => !1);\n  else if (r) {\n    if (u = x(!1, {\n      sid: \"barrier.$active\",\n      name: \"barrier.$active\"\n    }), \"failure\" in r && r.failure) {\n      const d = r.failure;\n      c({\n        clock: l,\n        filter: ({ error: w, params: P }) => d({ error: w, params: P }),\n        fn: () => !0,\n        target: [u, i]\n      }), c({\n        clock: Pt({\n          events: g.map(U(\"end\")),\n          reset: l\n        }),\n        fn: () => !1,\n        target: u\n      });\n    }\n  } else\n    throw new Error(\"Invalid configuration of createBarrier\");\n  const p = O(\n    u,\n    _,\n    (d, w) => w ? !1 : d\n  );\n  c({\n    clock: g.map(U(\"end\")),\n    target: s\n  }), J({\n    clock: [p, i],\n    source: p,\n    match: { activated: Boolean },\n    cases: { activated: a, __: o }\n  }), c({\n    clock: i,\n    filter: p,\n    target: wr(g)\n  });\n  const m = x(null, { serialize: \"ignore\" });\n  return c({\n    clock: i,\n    source: { mutex: m, active: p },\n    filter: ({ mutex: d }) => d === null,\n    fn: ({ active: d }) => new Et(d),\n    target: m\n  }), c({\n    clock: a,\n    target: T({\n      source: m,\n      effect(d) {\n        d == null || d.acquire();\n      }\n    })\n  }), c({\n    clock: o,\n    target: T({\n      source: m,\n      effect(d) {\n        d == null || d.release();\n      }\n    })\n  }), {\n    $active: E(p),\n    activated: E(a),\n    deactivated: E(o),\n    performed: E(s),\n    forceDeactivate: f,\n    __: { touch: i, operationFailed: l, operationDone: y, $mutex: m }\n  };\n}\nfunction wr(e) {\n  const t = $();\n  for (const { start: r, $pending: n } of e)\n    c({\n      clock: t,\n      filter: H(n),\n      target: r\n    });\n  return t;\n}\nfunction Ar(e) {\n  return e.map((t) => {\n    if (xr(t))\n      return {\n        start: t.start,\n        end: Se(\n          c({\n            clock: [t.finished.success, t.finished.skip]\n          })\n        ),\n        $pending: t.$pending\n      };\n    if (Er(t))\n      return {\n        start: t,\n        end: Se(t.done),\n        $pending: t.pending\n      };\n    {\n      const r = x(!1, { serialize: \"ignore\" }).on(t.start, () => !0).on(t.end, () => !1);\n      return { ...t, $pending: r };\n    }\n  });\n}\nfunction xr(e) {\n  return Ge(e) || cr(e);\n}\nfunction Er(e) {\n  return q.effect(e);\n}\nfunction Se(e) {\n  return c({\n    clock: e,\n    fn: () => {\n    }\n  });\n}\nexport {\n  ne as Meta,\n  Gt as NodeLinksSumbol,\n  Wt as NodeMetaSumbol,\n  ae as Result,\n  Ce as abortError,\n  br as applyBarrier,\n  Ur as attachOperation,\n  Vr as cache,\n  Sr as combineSourced,\n  Ve as concurrency,\n  ie as configurationError,\n  Rr as connectQuery,\n  Yr as createBarrier,\n  he as createCacheAdapter,\n  me as createHeadlessMutation,\n  de as createHeadlessQuery,\n  Lr as createJsonMutation,\n  qr as createJsonQuery,\n  Nr as createMutation,\n  Or as createQuery,\n  Wr as declareParams,\n  Cr as exponentialDelay,\n  nr as fetchFx,\n  Be as httpError,\n  mr as inMemoryCache,\n  ee as invalidDataError,\n  He as isHttpError,\n  Dr as isHttpErrorCode,\n  Fr as isInvalidDataError,\n  jr as isNetworkError,\n  Tr as isPreparationError,\n  Ir as isTimeoutError,\n  Gr as keepFresh,\n  zr as linearDelay,\n  Kr as localStorageCache,\n  Tt as networkError,\n  D as normalizeSourced,\n  Ue as onAbort,\n  It as preparationError,\n  Mr as retry,\n  Qr as sessionStorageCache,\n  Br as timeout,\n  Ft as timeoutError,\n  re as unknownContract,\n  Hr as update,\n  Jr as voidCache\n};\n",
      "start": 1750971640338,
      "end": 1750971640354,
      "sourcemaps": null
    },
    {
      "name": "@tailwindcss/vite:generate:build",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "pre"
    },
    {
      "name": "vite:esbuild",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "normal-normal"
    },
    {
      "name": "vite:vue",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "normal-normal"
    },
    {
      "name": "vite:build-html",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "normal-normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "normal-normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1750971640354,
      "end": 1750971640354,
      "order": "normal-normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1750971640357,
      "end": 1750971640357,
      "order": "normal-normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1750971640357,
      "end": 1750971640357,
      "order": "normal-normal"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1750971640357,
      "end": 1750971640357,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1750971640357,
      "end": 1750971640357,
      "order": "normal-normal"
    },
    {
      "name": "vite:reporter",
      "start": 1750971640357,
      "end": 1750971640357,
      "order": "normal"
    }
  ]
}
